#### Nestjs

1. Backend basic logic:
  - Request / Response  <=>  Validate data contained in the request(PIPE) => Make sure the user is authenticated(Guard) => route a request to a particular function(Controller) => Run some business logic(Service) => Access a data base(Repository).
  - Parts of Nestjs:
    - Controller -> handles the incoming request.
    - Services -> handles the data access and business logic.
    - Modules -> Groups together codes.
    - Pipes -> Validate incoming data.
    - DTO -> To validate incoming request bodies
    - Filters -> handles errors that happens during requests handling.
    - Guards -> Handles authentication.
    - Interceptors -> Add extra logic to incoming requests or outgoing response.
    - Repositories -> Handles data stored in a DB.


2. Detail of an api module (use UserModule for instance):
  - ApiModule
    - UserEntity: Lists the different properties that a User has.
    - Methods to find, update, delete and create a user.

3. Repositories of typeOrm:
  - create()
  - save()
  - insert()
  - update()
  - find(): run query
  - findOne(): run query return the first one
  - remove()
  - delete()
  
4. Definition of DTOs:
  - To validate incoming date in the body, so we gonna need class-validator and class-transformer
  - everything else is similar to the yup/zod, sort of.
  
5. Definition of Service:
  - Service is to call Repo's methods, in order to complete certain task --- create, update, delete, put......
  - the import should includes: Repository from typeorm
  - the import should includes: InjectRepository from @nestjs/typeorm  (you have a Repo then you need to inject it, pretty neat hah)
  - also the Entity themselves needs to be imported aswell.

6. Backend Flow:
  - Request => 
  - Validation Pipe(utilizing DTO to do the validation) => 
  - Controller(routing, retrive specific data from incoming request, filter harmful data if nessisary) => 
  - Service(utilizing the Entity), doing all the business logic
    - create / update / find / findOne / remove an entityInstance
    - all other business logics
    - save the entityInstance into the database 
    - => 
  - Repository(utilizing the Entity), Repo is generated by the typeorm and doing all the CRUD => 
  - DataBase well, just the data source

7. there are serveral hooks in the typeorm like @AfterUpdate @After

8. the reason why we dont use insert / update / delete is because they directly manipulate the data base, and won't trigger the hook. this may cause problems and we wont know why problems occurs.
